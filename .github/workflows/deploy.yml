name: CI/CD Deploy (staging / production)

on:
  push:
    branches:
      - staging
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Start SSH agent
        uses: webfactory/ssh-agent@v0.8.1
        with:
          ssh-private-key: ${{ secrets.DROPLET_SSH_KEY }}

      - name: Determine environment & targets
        id: env
        run: |
          BRANCH="${GITHUB_REF##*/}"
          if [ "$BRANCH" = "staging" ]; then
            echo "host=${{ secrets.STAGING_DROPLET_HOST }}" >> $GITHUB_OUTPUT
            echo "branch=staging" >> $GITHUB_OUTPUT
            echo "script=setup-docker.sh" >> $GITHUB_OUTPUT
            echo "compose_file=docker-compose.yml" >> $GITHUB_OUTPUT
          elif [ "$BRANCH" = "main" ]; then
            echo "host=${{ secrets.PROD_DROPLET_HOST }}" >> $GITHUB_OUTPUT
            echo "branch=main" >> $GITHUB_OUTPUT
            echo "script=setup_prod.sh" >> $GITHUB_OUTPUT
            echo "compose_file=docker-compose.prod.yml" >> $GITHUB_OUTPUT
          else
            echo "Not a deployable branch ($BRANCH). Exiting."
            exit 0
          fi

      - name: Deploy to target droplet (SSH + rollback)
        env:
          DROPLET_USER: ${{ secrets.DROPLET_USER }}
        run: |
          HOST="${{ steps.env.outputs.host }}"
          BRANCH="${{ steps.env.outputs.branch }}"
          SCRIPT="${{ steps.env.outputs.script }}"
          COMPOSE_FILE="${{ steps.env.outputs.compose_file }}"
          USER="${DROPLET_USER}"
          # Change this if your project lives elsewhere on the droplet:
          REMOTE_PATH="/root/ifrs9pro_backend"

          echo "Deploying branch '$BRANCH' to $HOST (remote path: $REMOTE_PATH) using script '$SCRIPT'"

          ssh -o StrictHostKeyChecking=no ${USER}@${HOST} << EOF
set -euo pipefail

echo "==> Entering \${REMOTE_PATH}"
cd "${REMOTE_PATH}" || { echo "Remote project path not found: ${REMOTE_PATH}"; exit 1; }

echo "==> Saving current commit (for rollback)..."
PREV_COMMIT=\$(git rev-parse HEAD)
echo "Previous commit: \$PREV_COMMIT"

echo "==> Fetching and updating to origin/${BRANCH}..."
git fetch --all --prune
git reset --hard origin/${BRANCH}

# Make sure scripts are executable
chmod +x "${SCRIPT}" || true

# Rollback function called on any error
rollback() {
  echo ">>> Deployment failed — attempting rollback to \$PREV_COMMIT"
  set +e
  git reset --hard "\$PREV_COMMIT" || echo "Failed to reset to previous commit"
  echo "Bringing services back up (best-effort)..."
  if command -v docker >/dev/null 2>&1; then
    # try docker compose with plugin, fallback to docker-compose if needed
    if docker compose version >/dev/null 2>&1; then
      docker compose -f "${COMPOSE_FILE}" -p ifrs9pro up -d --build || true
    else
      docker-compose -f "${COMPOSE_FILE}" -p ifrs9pro up -d --build || true
    fi
  fi
  echo "Rollback complete."
  exit 1
}

trap rollback ERR

echo "==> Running ${SCRIPT} ..."
# run the script that performs the build / migrations / startup
./${SCRIPT}

# If we reach here, success — cancel the trap
trap - ERR

echo "✅ Deployment script finished successfully."

EOF
