name: CI/CD Deploy (Docker Compose)

on:
  push:
    branches:
      - staging
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      SECRET_KEY: "default-test-secret"

    steps:
      # 1Ô∏è‚É£ Checkout
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 2Ô∏è‚É£ Python
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      # 3Ô∏è‚É£ Install dependencies
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest schemathesis

      # 4Ô∏è‚É£ Create fake site directory for tests
      - name: Create fake site directory
        run: |
          mkdir -p site

      # 5Ô∏è‚É£ Create CI-only .env file
      - name: Create CI environment file
        run: |
          echo "ACCESS_TOKEN_EXPIRE_HOURS=1" >> .env
          echo "ACCESS_TOKEN_EXPIRE_MINUTES=15" >> .env
          echo "DEBUG=True" >> .env
          echo "INVITATION_EXPIRE_HOURS=1" >> .env

          echo "FRONTEND_BASE_URL=http://localhost:3000" >> .env
          echo "BASE_URL=http://localhost:8000" >> .env

          echo "SECRET_KEY=test-secret-key" >> .env

          echo "ADMIN_EMAIL=admin@example.com" >> .env
          echo "ADMIN_PASSWORD=admin123" >> .env
          echo "SUPERADMIN_EMAIL=superadmin@example.com" >> .env
          echo "SUPERADMIN_PASSWORD=superadmin123" >> .env

          # CI Postgres
          echo "SQLALCHEMY_DATABASE_URL=postgresql://testuser:testpass@db:5432/testdb" >> .env
          echo "POSTGRES_PASSWORD=testpass" >> .env
          echo "POSTGRES_USER=testuser" >> .env
          echo "POSTGRES_DB=testdb" >> .env

          # CI Minio
          echo "MINIO_ENDPOINT=http://minio:9000" >> .env
          echo "MINIO_PUBLIC_ENDPOINT=http://localhost:9000" >> .env
          echo "MINIO_ACCESS_KEY=minio" >> .env
          echo "MINIO_SECRET_KEY=miniostorage" >> .env
          echo "MINIO_BUCKET_NAME=ci-bucket" >> .env
          echo "MINIO_USE_SSL=False" >> .env

          # Dummy external services
          echo "AZURE_COMMUNICATION_CONNECTION_STRING=dummy" >> .env
          echo "AZURE_SENDER_EMAIL=test@example.com" >> .env
          echo "BREVO_API_KEY=dummy" >> .env
          echo "SENDER_EMAIL=test@example.com" >> .env
          echo "SMTP_HOST=localhost" >> .env
          echo "SMTP_PORT=1025" >> .env
          echo "SMTP_USERNAME=dummy" >> .env
          echo "SMTP_PASSWORD=dummy" >> .env
          echo "SMTP_USE_TLS=false" >> .env
          echo "SMTP_FROM=test@example.com" >> .env

          echo "MAILJET_API_KEY=dummy" >> .env
          echo "MAILJET_API_SECRET=dummy" >> .env
          echo "MAILJET_SENDER_EMAIL=test@example.com" >> .env
          echo "MAILJET_SENDER_NAME=Test" >> .env
          echo "MAILJET_SMTP_HOST=localhost" >> .env
          echo "MAILJET_SMTP_PORT=1025" >> .env

          echo "CONTAINER_NAME=ci-container" >> .env
          echo "TENANT_DEFAULT=test-tenant" >> .env
          echo "PAYSTACK_SECRET_KEY=dummy" >> .env

          echo "TEST_DATABASE_URL=postgresql://testuser:testpass@db:5432/testdb" >> .env

          echo "Created CI .env file:"
          cat .env

      # 6Ô∏è‚É£ Run pytest
      - name: Run tests
        run: |
          echo "Running pytest..."
          python -m pytest tests || { echo "‚ùå Pytest failed"; exit 1; }

      # 7Ô∏è‚É£ Run Spectral
      - name: Run Spectral
        run: |
          echo "Running Spectral..."
          docker run --rm -v "$PWD:/work" -w /work \
            stoplight/spectral:latest lint \
            --ruleset /work/.spectral.yaml \
            /work/openapi.yaml || { echo "‚ùå Spectral lint failed"; exit 1; }

      # 8Ô∏è‚É£ Start Docker Compose stack
      - name: Start API stack (db + minio + fastapi)
        run: |
          echo "Starting docker-compose.local.yml..."
          docker compose -f docker-compose.local.yml up -d
          echo "Waiting 25 seconds for services to be healthy..."
          sleep 25

      # 9Ô∏è‚É£ Verify FastAPI is reachable
      - name: Check API health before testing
        run: |
          echo "Checking API at http://localhost:8000/health..."
          curl -f http://localhost:8000/health || { echo "‚ùå API is not healthy"; exit 1; }

      # üîü Schemathesis tests
      - name: Run Schemathesis API tests
        run: |
          echo "Running Schemathesis API tests..."
          PYTHONPATH=$(pwd) schemathesis run http://localhost:8000/openapi.json \
            --experimental=openapi-3.1 \
            --checks=not_a_server_error,content_type_conformance,status_code_conformance,response_schema_conformance \
            --exclude-path-regex "^POST /request-access$|^POST /submit-admin-request$|^POST /login$" || true


      # 1Ô∏è‚É£1Ô∏è‚É£ Export OpenAPI schema
      - name: Export OpenAPI schema
        run: |
          echo "Saving OpenAPI schema as YAML..."
          mkdir -p artifacts
          curl -f http://localhost:8000/openapi.json -o artifacts/openapi.json
          python - <<'PY'
          import json, yaml
          with open("artifacts/openapi.json") as f:
            data = json.load(f)
          with open("artifacts/openapi.yaml", "w") as f:
            yaml.dump(data, f, sort_keys=False)
          PY

      # 1Ô∏è‚É£2Ô∏è‚É£ Upload OpenAPI schema
      - name: Upload OpenAPI schema
        uses: actions/upload-artifact@v4
        with:
          name: openapi-schema
          path: artifacts/openapi.yaml

      # 1Ô∏è‚É£3Ô∏è‚É£ Publish spec to Github Release
      - name: Create release and upload OpenAPI
        uses: softprops/action-gh-release@v2
        with:
          tag_name: api-${{ github.sha }}
          files: artifacts/openapi.yaml

      # 1Ô∏è‚É£4Ô∏è‚É£ Stop Docker Compose
      - name: Tear down API stack
        if: always()
        run: docker compose -f docker-compose.local.yml down

      # 15Ô∏è‚É£ Determine deploy target
      - name: Set deployment variables
        id: vars
        run: |
          if [ "${{ github.ref_name }}" = "staging" ]; then
            echo "SCRIPT=setup-docker.sh" >> $GITHUB_OUTPUT
          else
            echo "SCRIPT=setup_prod.sh" >> $GITHUB_OUTPUT
          fi

      # 16Ô∏è‚É£ Deploy to Staging (SSH Key only)
      - name: Deploy to Staging
        if: github.ref_name == 'staging'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.STAGING_SSH_HOST }}
          username: ${{ secrets.STAGING_SSH_USER }}
          key: ${{ secrets.STAGING_SSH_KEY }}
          port: 22
          script: |
            export REMOTE_PATH=~/ifrs9pro_backend
            export SCRIPT=${{ steps.vars.outputs.SCRIPT }}
            cd "$REMOTE_PATH" || { echo "Remote path not found: $REMOTE_PATH"; exit 1; }
            echo "Pulling latest changes..."
            git fetch origin
            git reset --hard origin/$(git rev-parse --abbrev-ref HEAD)
            chmod +x "$SCRIPT" || true
            ./"$SCRIPT"
            echo "‚úÖ Staging deployment completed successfully."

      # 17Ô∏è‚É£ Deploy to Production (SSH Key only)
      - name: Deploy to Production
        if: github.ref_name == 'main'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.PROD_SSH_HOST }}
          username: ${{ secrets.PROD_SSH_USER }}
          key: ${{ secrets.PROD_SSH_KEY }}
          port: 22
          script: |
            export REMOTE_PATH=~/ifrs9pro_backend
            export SCRIPT=${{ steps.vars.outputs.SCRIPT }}
            cd "$REMOTE_PATH" || { echo "Remote path not found: $REMOTE_PATH"; exit 1; }
            echo "Pulling latest changes..."
            git fetch origin
            git reset --hard origin/$(git rev-parse --abbrev-ref HEAD)
            chmod +x "$SCRIPT" || true
            ./"$SCRIPT"
            echo "‚úÖ Production deployment completed successfully."